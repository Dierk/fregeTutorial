module suggest.LineProducer where


type Consumer     s a b = a → b → ST s a
type LineConsumer s a   = Consumer s a String

data Operation s a p = Op {
    produce :: a → ST s p,
    consume :: a → p → ST s a
} where
    operate :: Operation s a p -> a -> ST s a
    operate op a = do
       p <- op.produce a
       op.consume a p

op = Op {
    produce = \a -> return "42",
    consume = \a p -> return $ a + 1
}

foo = op.operate 0


{--
    @LineProducer@ is a class for all types that support a common interface for in-place
    line-by-line processing.

    Notable examples are @BufferedReader@, @File@, @URL@, and @stdin@, while
    some line producers are not even IO dependent like @StringReader@ and @StringGenerator@.
-}
class LineProducer lp where
    {-- The _onLine_ function is called to process a line whenever a line is produced.

        > onLine lineProducer startValue handler

        where _handler_ is a function that takes an accumulator of the same type as the _startValue_ and
        the newly produced line as a @String@. The _handler_ returns the accumulated value as the result of a
        state transition (most often that is IO).

        The _onLine_ function returns the total accumulated value as the result of a state transition.
    -}
    onLine  :: Mutable s lp → a → LineConsumer s a → ST s a

    --- The _offLine_ function stops further production of lines.
    offLine :: Mutable s lp → ST s ()

instance LineProducer BufferedReader where
    onLine :: Mutable s BufferedReader → a → LineConsumer s a → ST s a
    onLine bufferedReader value handler = do
        line <- bufferedReader.readLine
            `catch` \(e :: IOException)  -> return Nothing
        case line of
            Nothing   -> do
                offLine bufferedReader
                return value
            Just line -> do
                newValue <- handler value line
                onLine bufferedReader newValue handler
    offLine :: Mutable s BufferedReader → ST s ()
    offLine bufferedReader = bufferedReader.close

data StringReader = native java.io.StringReader where
    native new      :: String -> STMutable s StringReader
    native close    :: Mutable s StringReader -> ST s ()

instance LineProducer StringReader where
    onLine  :: Mutable s StringReader → a → LineConsumer s a → ST s a
    onLine  stringReader value handler = (BufferedReader.new stringReader) >>= \br -> onLine br value handler
    offLine :: Mutable s StringReader → ST s ()
    offLine stringReader = stringReader.close

data FileInputStream = native java.io.FileInputStream where
    native new :: String  -> STMutable s FileInputStream        -- todo: needs to be changed in frege
                    throws FileNotFoundException

openReader :: String -> STMutable s BufferedReader              -- todo: needs to be changed in frege
openReader fileName = do
    fis <- FileInputStream.new (fileName :: String )
    isr <- InputStreamReader.new fis "UTF-8"
    BufferedReader.new isr

data LpFile = native java.io.File where
    native new           :: String -> STMutable s LpFile
    native getPath       :: Mutable s LpFile -> ST s String

-- convenience function, not really needed
makeMutable :: File -> STMutable s LpFile
makeMutable file = LpFile.new file.getPath

{- Convenience functions for line producers that delegate to a buffered reader and
   signal the end of processing via throwing EOF, which we catch and properly
   close the reader.
-}
private relayWithCatch bufferedReader value handler =
    onLine bufferedReader value $ \currentState line -> do
        handler currentState line `catch` \(e :: EOFException) -> do
            offLine bufferedReader
            return currentState
private relayOffLine _ = do
    throwST (EOFException.new "end of lines")
    return ()

instance LineProducer LpFile where
    onLine  :: Mutable s LpFile → a → LineConsumer s a → ST s a
    onLine  file value handler = do
        path <- file.getPath
        bufferedReader <- openReader path -- todo allow more encodings than UTF-8
        relayWithCatch bufferedReader value handler
    offLine :: Mutable s LpFile → ST s ()
    offLine = relayOffLine

data MalformedURLException = pure native java.net.MalformedURLException  -- not needed after integration
derive Exceptional MalformedURLException

data LpURL = native java.net.URL where
    native new              :: String -> STMutable s LpURL                throws MalformedURLException
    native openStream       :: Mutable s LpURL -> STMutable s InputStream throws IOException

instance LineProducer LpURL where
    onLine  :: Mutable s LpURL → a → LineConsumer s a → ST s a
    onLine  xurl value handler = do
        uis <- LpURL.openStream xurl
        isr <- InputStreamReader.new uis "UTF-8"    -- todo: encoding depends on the protocol ...
        bufferedReader <- BufferedReader.new isr
        relayWithCatch bufferedReader value handler
    offLine :: Mutable s LpURL → ST s ()
    offLine = relayOffLine

-- convenience output
printIOValue prefix ioValue = do  -- same as:  (prefix ++) . show <$> ioValue >>= println
    value <- ioValue
    println $ prefix ++ show value

countStringReaderLines :: ST s Int
countStringReaderLines = do
    stringReader <- StringReader.new $ unlines ["first","second","third"]
    result <- stringReader.onLine 0 $ \num _ -> return  $ num + 1
    return result

data StrGenData = StrGen {
    proceed     :: Bool,                -- if false we stop generating lines
    line        :: String,              -- the currently generated line, "onLine" will be called with this
    nextLine    :: String -> String     -- the generation function for the next line
}
type StringGenerator = Ref StrGenData   -- a mutable reference to the generator data

instance LineProducer StringGenerator where
    onLine  :: Mutable s StringGenerator → a → LineConsumer s a → ST s a
    onLine  strGen value handler = do
        state <- strGen.get
        if state.proceed
        then do
            newValue <- handler value state.line        -- call handler with the last generated line (might call offLine)
            strGen.modify _.{line <- state.nextLine}    -- generate the next line
            onLine strGen newValue handler              -- continue processing with updated values
        else
            return value
    offLine :: Mutable s StringGenerator → ST s ()
    offLine strGen = strGen.modify _.{proceed = false}  -- called by handler to stop generating lines

main = do
    testFile = File.new "TestFile.txt"              -- since version 3.25, otherwise <- instead of =

    println "----------------------------------------"
    println "general file handling"
    -- delete test file if it already existed
    printIOValue "Test file deleted to clean up before start: " testFile.delete

    println "create test file"
    writeFile testFile.getPath $ unlines ["first line","second line","third line"]
    printIOValue "File now exists: " testFile.exists

    println "read test file in toto"
    content <- readFile testFile.getPath
    println "file content was:"
    println content

    println "append 2 lines"
    appendFile testFile.getPath $ unlines ["fourth line","fifth line"]

    println "----------------------------------------"
    println "processing each line with a buffered reader, while keeping track of line numbers"
    bufferedReader <- openReader testFile.getPath
    count <- bufferedReader.onLine 0 $ \num line -> do
        println $ show (num + 1) ++ ": " ++ line
        return  $ num + 1
    println $ "total number of lines: " ++ show count

    println "----------------------------------------"
    println "processing each line from a file, pushing each line on a stack"
    mutFile <- makeMutable testFile
    stack   <- mutFile.onLine [] $ \stack line -> return (line : stack)
    println $ "total stack" ++ show stack

    println "----------------------------------------"
    println "reading only one line (a header for example)"
    oneLineReader <- openReader testFile.getPath
    header <- oneLineReader.onLine "" $ \state line -> do
        offLine oneLineReader -- make sure the next read yields no more lines
        return line
    println $ "the header line is: " ++ show header

    println "----------------------------------------"
    println "processing each line with a non-IO impure reader, here: StringReader. (great for testing)"
    numLines <- countStringReaderLines
    println $ "processing strings with StringReader works as expected: " ++ show (3 == numLines)

    println "----------------------------------------"
    println "reading from a URL"
    urlReader <- LpURL.new "http://google.com"
    result <- urlReader.onLine 0 $ \num line -> do
        println $ show num ++ ": " ++ line.substr 0 10
        if (num > 3) then urlReader.offLine else return ()
        return  $ num + 1
    println $ "processing strings from URL works as expected: " ++ show (result == 4)

    println "----------------------------------------"
    println "reading from a StringGenerator"
    strGenRef <- Ref.new $ StrGen { proceed = true, line = "", nextLine = (++ "x") }
    result <- strGenRef.onLine 0 $ \num line ->
        if (num > 3)
        then do
            strGenRef.offLine
            return num
        else do
            println $ show num ++ ": " ++ line
            return  $ num + 1
    println $ "StringGenerator works as expected: " ++ show (result == 4)

cli = do
    println "command line input (max 10 lines or send EOF via Cmd/Ctrl-D)"
    stdin.onLine 0 $ \num line -> do
        println $ show (num + 1) ++ ": " ++ line
        if (num > 9) then stdin.offLine else return ()
        return  $ num + 1
    return ()
